{
    "intro": "Master advanced element location techniques!",
    "outro": "Excellent! You've mastered element location strategies!",
    "sections": [
        {
            "annotation": "Using CSS selectors for precise targeting",
            "code_string": "from selenium import webdriver\nfrom selenium.webdriver.common.by import By\n\ndriver = webdriver.Chrome()\ndriver.get(\"https://example.com\")\n\n# CSS Selector examples\nheader = driver.find_element(By.CSS_SELECTOR, \"h1.main-title\")\nbutton = driver.find_element(By.CSS_SELECTOR, \"button[type='submit']\")",
            "explanation": "CSS selectors offer flexible element targeting. Class selectors use dots. Attribute selectors use square brackets for specificity.",
            "highlight_lines": [
                8,
                9
            ]
        },
        {
            "annotation": "XPath for hierarchical and text-based selection",
            "code_string": "# XPath for complex element location\nfirst_item = driver.find_element(By.XPATH, \"//ul[@class='menu']/li[1]\")\ntext_contains = driver.find_element(By.XPATH, \"//p[contains(text(), 'Welcome')]\")\nparent_element = driver.find_element(By.XPATH, \"//span/../div\")\n\nprint(f\"Found elements using XPath\")",
            "explanation": "XPath navigates DOM hierarchy effectively. contains() function finds partial text matches. Parent-child relationships enable complex selections.",
            "highlight_lines": [
                2,
                3,
                4
            ]
        },
        {
            "annotation": "Working with multiple elements at once",
            "code_string": "# Finding multiple elements\nall_links = driver.find_elements(By.TAG_NAME, \"a\")\nall_buttons = driver.find_elements(By.CSS_SELECTOR, \"button\")\n\nprint(f\"Found {len(all_links)} links\")\nfor i, link in enumerate(all_links[:3]):\n    print(f\"Link {i+1}: {link.get_attribute('href')}\")",
            "explanation": "find_elements returns list of matching elements. Iterate through collections for batch operations. get_attribute extracts element properties.",
            "highlight_lines": [
                2,
                3,
                6,
                7
            ]
        },
        {
            "annotation": "Chaining selectors and checking element states",
            "code_string": "# Chaining locators for nested elements\nnavbar = driver.find_element(By.ID, \"navbar\")\nmenu_item = navbar.find_element(By.CLASS_NAME, \"menu-item\")\n\n# Element properties and states\nprint(f\"Element visible: {menu_item.is_displayed()}\")\nprint(f\"Element enabled: {menu_item.is_enabled()}\")\ndriver.quit()",
            "explanation": "Chain find_element calls for nested searching. is_displayed() checks visibility. is_enabled() verifies interaction capability.",
            "highlight_lines": [
                2,
                3,
                6,
                7
            ]
        }
    ]
}